// Generated by CoffeeScript 1.6.1
(function() {
  var _this = this,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  this.Problem = (function() {
    var _this = this;

    function Problem(element) {
      var _this = this;
      this.hint_button = function() {
        return Problem.prototype.hint_button.apply(_this, arguments);
      };
      this.enableCheckButtonAfterTimeout = function() {
        return Problem.prototype.enableCheckButtonAfterTimeout.apply(_this, arguments);
      };
      this.enableCheckButtonAfterResponse = function() {
        return Problem.prototype.enableCheckButtonAfterResponse.apply(_this, arguments);
      };
      this.enableCheckButton = function(enable, changeText) {
        if (changeText == null) {
          changeText = true;
        }
        return Problem.prototype.enableCheckButton.apply(_this, arguments);
      };
      this.enableAllButtons = function(enable, isFromCheckOperation) {
        return Problem.prototype.enableAllButtons.apply(_this, arguments);
      };
      this.disableAllButtonsWhileRunning = function(operationCallback, isFromCheckOperation) {
        return Problem.prototype.disableAllButtonsWhileRunning.apply(_this, arguments);
      };
      this.refreshAnswers = function() {
        return Problem.prototype.refreshAnswers.apply(_this, arguments);
      };
      this.updateMathML = function(jax, element) {
        return Problem.prototype.updateMathML.apply(_this, arguments);
      };
      this.refreshMath = function(event, element) {
        return Problem.prototype.refreshMath.apply(_this, arguments);
      };
      this.save_internal = function() {
        return Problem.prototype.save_internal.apply(_this, arguments);
      };
      this.save = function() {
        return Problem.prototype.save.apply(_this, arguments);
      };
      this.gentle_alert = function(msg) {
        return Problem.prototype.gentle_alert.apply(_this, arguments);
      };
      this.show = function() {
        return Problem.prototype.show.apply(_this, arguments);
      };
      this.reset_internal = function() {
        return Problem.prototype.reset_internal.apply(_this, arguments);
      };
      this.reset = function() {
        return Problem.prototype.reset.apply(_this, arguments);
      };
      this.check_internal = function() {
        return Problem.prototype.check_internal.apply(_this, arguments);
      };
      this.check = function() {
        return Problem.prototype.check.apply(_this, arguments);
      };
      this.check_fd = function() {
        return Problem.prototype.check_fd.apply(_this, arguments);
      };
      this.check_save_waitfor = function(callback) {
        return Problem.prototype.check_save_waitfor.apply(_this, arguments);
      };
      this.setupInputTypes = function() {
        return Problem.prototype.setupInputTypes.apply(_this, arguments);
      };
      this.poll = function(prev_timeout) {
        return Problem.prototype.poll.apply(_this, arguments);
      };
      this.queueing = function() {
        return Problem.prototype.queueing.apply(_this, arguments);
      };
      this.forceUpdate = function(response) {
        return Problem.prototype.forceUpdate.apply(_this, arguments);
      };
      this.updateProgress = function(response) {
        return Problem.prototype.updateProgress.apply(_this, arguments);
      };
      this.renderProgressState = function() {
        return Problem.prototype.renderProgressState.apply(_this, arguments);
      };
      this.bind = function() {
        return Problem.prototype.bind.apply(_this, arguments);
      };
      this.el = $(element).find('.problems-wrapper');
      this.id = this.el.data('problem-id');
      this.element_id = this.el.attr('id');
      this.url = this.el.data('url');
      this.has_timed_out = false;
      this.has_response = false;
      this.render();
    }

    Problem.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    Problem.prototype.bind = function() {
      var problem_prefix,
        _this = this;
      if (typeof MathJax !== "undefined" && MathJax !== null) {
        this.el.find('.problem > div').each(function(index, element) {
          return MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
        });
      }
      window.update_schematics();
      problem_prefix = this.element_id.replace(/problem_/, '');
      this.inputs = this.$("[id^='input_" + problem_prefix + "_']");
      this.$('div.action button').click(this.refreshAnswers);
      this.checkButton = this.$('div.action button.check');
      this.checkButtonLabel = this.$('div.action button.check span.check-label');
      this.checkButtonCheckText = this.checkButtonLabel.text();
      this.checkButtonCheckingText = this.checkButton.data('checking');
      this.checkButton.click(this.check_fd);
      this.hintButton = this.$('div.action button.hint-button');
      this.hintButton.click(this.hint_button);
      this.resetButton = this.$('div.action button.reset');
      this.resetButton.click(this.reset);
      this.showButton = this.$('div.action button.show');
      this.showButton.click(this.show);
      this.saveButton = this.$('div.action button.save');
      this.saveButton.click(this.save);
      this.$('.clarification').focus(function(ev) {
        var icon;
        icon = $(ev.target).children("i");
        return window.globalTooltipManager.openTooltip(icon);
      });
      this.$('.clarification').blur(function(ev) {
        return window.globalTooltipManager.hide();
      });
      this.bindResetCorrectness();
      Collapsible.setCollapsibles(this.el);
      this.$('input.math').keyup(this.refreshMath);
      if (typeof MathJax !== "undefined" && MathJax !== null) {
        return this.$('input.math').each(function(index, element) {
          return MathJax.Hub.Queue([_this.refreshMath, null, element]);
        });
      }
    };

    Problem.prototype.renderProgressState = function() {
      var a, detail, earned, possible, progress, progress_template, status;
      detail = this.el.data('progress_detail');
      status = this.el.data('progress_status');
      if (status !== 'none' && (detail != null) && detail.indexOf('/') > 0) {
        a = detail.split('/');
        earned = parseFloat(a[0]);
        possible = parseFloat(a[1]);
        // Translators: %(earned)s is the number of points earned. %(total)s is the total number of points (examples: 0/1, 1/1, 2/3, 5/10). The total number of points will always be at least 1. We pluralize based on the total number of points (example: 0/1 point; 1/2 points);
        progress_template = ngettext('(%(earned)s/%(possible)s point)', '(%(earned)s/%(possible)s points)', possible);
        progress = interpolate(progress_template, {
          'earned': earned,
          'possible': possible
        }, true);
      }
      if (status === 'none' && (detail != null) && detail.indexOf('/') > 0) {
        a = detail.split('/');
        possible = parseFloat(a[1]);
        // Translators: %(num_points)s is the number of points possible (examples: 1, 3, 10). There will always be at least 1 point possible.;
        progress_template = ngettext("(%(num_points)s point possible)", "(%(num_points)s points possible)", possible);
        progress = interpolate(progress_template, {
          'num_points': possible
        }, true);
      }
      return this.$('.problem-progress').html(progress);
    };

    Problem.prototype.updateProgress = function(response) {
      if (response.progress_changed) {
        this.el.data('progress_status', response.progress_status);
        this.el.data('progress_detail', response.progress_detail);
        this.el.trigger('progressChanged');
      }
      return this.renderProgressState();
    };

    Problem.prototype.forceUpdate = function(response) {
      this.el.data('progress_status', response.progress_status);
      this.el.data('progress_detail', response.progress_detail);
      this.el.trigger('progressChanged');
      return this.renderProgressState();
    };

    Problem.prototype.queueing = function() {
      var _this = this;
      this.queued_items = this.$(".xqueue");
      this.num_queued_items = this.queued_items.length;
      if (this.num_queued_items > 0) {
        if (window.queuePollerID) {
          window.clearTimeout(window.queuePollerID);
        }
        return window.queuePollerID = window.setTimeout(function() {
          return _this.poll(1000);
        }, 1000);
      }
    };

    Problem.prototype.poll = function(prev_timeout) {
      var _this = this;
      return $.postWithPrefix("" + this.url + "/problem_get", function(response) {
        var new_timeout;
        _this.new_queued_items = $(response.html).find(".xqueue");
        if (_this.new_queued_items.length !== _this.num_queued_items) {
          _this.el.html(response.html);
          JavascriptLoader.executeModuleScripts(_this.el, function() {
            _this.setupInputTypes();
            return _this.bind();
          });
        }
        _this.num_queued_items = _this.new_queued_items.length;
        if (_this.num_queued_items === 0) {
          _this.forceUpdate(response);
          return delete window.queuePollerID;
        } else {
          new_timeout = prev_timeout * 2;
          if (new_timeout >= 60000) {
            delete window.queuePollerID;
            return _this.gentle_alert(gettext("The grading process is still running. Refresh the page to see updates."));
          } else {
            return window.queuePollerID = window.setTimeout(function() {
              return _this.poll(new_timeout);
            }, new_timeout);
          }
        }
      });
    };

    Problem.inputAjax = function(url, input_id, dispatch, data, callback) {
      data['dispatch'] = dispatch;
      data['input_id'] = input_id;
      return $.postWithPrefix("" + url + "/input_ajax", data, callback);
    };

    Problem.prototype.render = function(content) {
      var _this = this;
      if (content) {
        this.el.attr({
          'aria-busy': 'true',
          'aria-live': 'off',
          'aria-atomic': 'false'
        });
        this.el.html(content);
        JavascriptLoader.executeModuleScripts(this.el, function() {
          _this.setupInputTypes();
          _this.bind();
          _this.queueing();
          return _this.renderProgressState();
        });
        return this.el.attr('aria-busy', 'false');
      } else {
        return $.postWithPrefix("" + this.url + "/problem_get", function(response) {
          _this.el.html(response.html);
          return JavascriptLoader.executeModuleScripts(_this.el, function() {
            _this.setupInputTypes();
            _this.bind();
            _this.queueing();
            return _this.forceUpdate(response);
          });
        });
      }
    };

    Problem.prototype.setupInputTypes = function() {
      var _this = this;
      this.inputtypeDisplays = {};
      return this.el.find(".capa_inputtype").each(function(index, inputtype) {
        var classes, cls, id, setupMethod, _i, _len, _results;
        classes = $(inputtype).attr('class').split(' ');
        id = $(inputtype).attr('id');
        _results = [];
        for (_i = 0, _len = classes.length; _i < _len; _i++) {
          cls = classes[_i];
          setupMethod = _this.inputtypeSetupMethods[cls];
          if (setupMethod != null) {
            _results.push(_this.inputtypeDisplays[id] = setupMethod(inputtype));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    };

    Problem.prototype.check_save_waitfor = function(callback) {
      var flag, inp, _i, _len, _ref,
        _this = this;
      flag = false;
      _ref = this.inputs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        inp = _ref[_i];
        if ($(inp).is("input[waitfor]")) {
          try {
            $(inp).data("waitfor")(function() {
              _this.refreshAnswers();
              return callback();
            });
          } catch (e) {
            if (e.name === "Waitfor Exception") {
              alert(e.message);
            } else {
              alert("Could not grade your answer. The submission was aborted.");
            }
            throw e;
          }
          flag = true;
        } else {
          flag = false;
        }
      }
      return flag;
    };

    /*
    # 'check_fd' uses FormData to allow file submissions in the 'problem_check' dispatch,
    #      in addition to simple querystring-based answers
    #
    # NOTE: The dispatch 'problem_check' is being singled out for the use of FormData;
    #       maybe preferable to consolidate all dispatches to use FormData
    */


    Problem.prototype.check_fd = function() {
      var abort_submission, error, error_html, errors, fd, file_not_selected, file_too_large, max_filesize, required_files_not_submitted, settings, timeout_id, unallowed_file_submitted, _i, _len,
        _this = this;
      if (this.el.find('input:file').length === 0) {
        this.check();
        return;
      }
      this.enableCheckButton(false);
      if (!window.FormData) {
        alert("Submission aborted! Sorry, your browser does not support file uploads. If you can, please use Chrome or Safari which have been verified to support file uploads.");
        this.enableCheckButton(true);
        return;
      }
      timeout_id = this.enableCheckButtonAfterTimeout();
      fd = new FormData();
      max_filesize = 4 * 1000 * 1000;
      file_too_large = false;
      file_not_selected = false;
      required_files_not_submitted = false;
      unallowed_file_submitted = false;
      errors = [];
      this.inputs.each(function(index, element) {
        var allowed_files, file, max_size, required_files, _i, _len, _ref, _ref1, _ref2;
        if (element.type === 'file') {
          required_files = $(element).data("required_files");
          allowed_files = $(element).data("allowed_files");
          _ref = element.files;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            file = _ref[_i];
            if (allowed_files.length !== 0 && (_ref1 = file.name, __indexOf.call(allowed_files, _ref1) < 0)) {
              unallowed_file_submitted = true;
              errors.push("You submitted " + file.name + "; only " + allowed_files + " are allowed.");
            }
            if (_ref2 = file.name, __indexOf.call(required_files, _ref2) >= 0) {
              required_files.splice(required_files.indexOf(file.name), 1);
            }
            if (file.size > max_filesize) {
              file_too_large = true;
              max_size = max_filesize / (1000 * 1000);
              errors.push("Your file " + file.name + " is too large (max size: {max_size}MB)");
            }
            fd.append(element.id, file);
          }
          if (element.files.length === 0) {
            file_not_selected = true;
            fd.append(element.id, '');
          }
          if (required_files.length !== 0) {
            required_files_not_submitted = true;
            return errors.push("You did not submit the required files: " + required_files + ".");
          }
        } else {
          return fd.append(element.id, element.value);
        }
      });
      if (file_not_selected) {
        errors.push('You did not select any files to submit');
      }
      error_html = '<ul>\n';
      for (_i = 0, _len = errors.length; _i < _len; _i++) {
        error = errors[_i];
        error_html += '<li>' + error + '</li>\n';
      }
      error_html += '</ul>';
      this.gentle_alert(error_html);
      abort_submission = file_too_large || file_not_selected || unallowed_file_submitted || required_files_not_submitted;
      if (abort_submission) {
        window.clearTimeout(timeout_id);
        this.enableCheckButton(true);
        return;
      }
      settings = {
        type: "POST",
        data: fd,
        processData: false,
        contentType: false,
        complete: this.enableCheckButtonAfterResponse,
        success: function(response) {
          switch (response.success) {
            case 'incorrect':
            case 'correct':
              _this.render(response.contents);
              _this.updateProgress(response);
              break;
            default:
              _this.gentle_alert(response.success);
          }
          return Logger.log('problem_graded', [_this.answers, response.contents], _this.id);
        }
      };
      return $.ajaxWithPrefix("" + this.url + "/problem_check", settings);
    };

    Problem.prototype.check = function() {
      if (!this.check_save_waitfor(this.check_internal)) {
        return this.disableAllButtonsWhileRunning(this.check_internal, true);
      }
    };

    Problem.prototype.check_internal = function() {
      var _this = this;
      Logger.log('problem_check', this.answers);
      return $.postWithPrefix("" + this.url + "/problem_check", this.answers, function(response) {
        switch (response.success) {
          case 'incorrect':
          case 'correct':
            window.SR.readElts($(response.contents).find('.status'));
            _this.render(response.contents);
            _this.updateProgress(response);
            if (_this.el.hasClass('showed')) {
              _this.el.removeClass('showed');
            }
            _this.$('div.action button.check').focus();
            break;
          default:
            _this.gentle_alert(response.success);
        }
        return Logger.log('problem_graded', [_this.answers, response.contents], _this.id);
      });
    };

    Problem.prototype.reset = function() {
      return this.disableAllButtonsWhileRunning(this.reset_internal, false);
    };

    Problem.prototype.reset_internal = function() {
      var _this = this;
      Logger.log('problem_reset', this.answers);
      return $.postWithPrefix("" + this.url + "/problem_reset", {
        id: this.id
      }, function(response) {
        _this.render(response.html);
        return _this.updateProgress(response);
      });
    };

    Problem.prototype.show = function() {
      var answer_text,
        _this = this;
      if (!this.el.hasClass('showed')) {
        Logger.log('problem_show', {
          problem: this.id
        });
        answer_text = [];
        return $.postWithPrefix("" + this.url + "/problem_show", function(response) {
          var answers;
          answers = response.answers;
          $.each(answers, function(key, value) {
            var answer, choice, solution, _i, _len, _results;
            if ($.isArray(value)) {
              _results = [];
              for (_i = 0, _len = value.length; _i < _len; _i++) {
                choice = value[_i];
                _this.$("label[for='input_" + key + "_" + choice + "']").attr({
                  correct_answer: 'true'
                });
                _results.push(answer_text.push('<p>' + gettext('Answer:') + ' ' + value + '</p>'));
              }
              return _results;
            } else {
              answer = _this.$("#answer_" + key + ", #solution_" + key);
              answer.html(value);
              Collapsible.setCollapsibles(answer);
              try {
                solution = $(value).find('.detailed-solution');
              } catch (e) {
                solution = {};
              }
              if (solution.length) {
                return answer_text.push(solution);
              } else {
                return answer_text.push('<p>' + gettext('Answer:') + ' ' + value + '</p>');
              }
            }
          });
          _this.el.find(".capa_inputtype").each(function(index, inputtype) {
            var classes, cls, display, showMethod, _i, _len, _results;
            classes = $(inputtype).attr('class').split(' ');
            _results = [];
            for (_i = 0, _len = classes.length; _i < _len; _i++) {
              cls = classes[_i];
              display = _this.inputtypeDisplays[$(inputtype).attr('id')];
              showMethod = _this.inputtypeShowAnswerMethods[cls];
              if (showMethod != null) {
                _results.push(showMethod(inputtype, display, answers));
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          });
          if (typeof MathJax !== "undefined" && MathJax !== null) {
            _this.el.find('.problem > div').each(function(index, element) {
              return MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
            });
          }
          // Translators: the word Answer here refers to the answer to a problem the student must solve.;
          _this.$('.show-label').text(gettext('Hide Answer'));
          _this.el.addClass('showed');
          _this.updateProgress(response);
          return window.SR.readElts(answer_text);
        });
      } else {
        this.$('[id^=answer_], [id^=solution_]').text('');
        this.$('[correct_answer]').attr({
          correct_answer: null
        });
        this.el.removeClass('showed');
        // Translators: the word Answer here refers to the answer to a problem the student must solve.;
        this.$('.show-label').text(gettext('Show Answer'));
        window.SR.readText(gettext('Answer hidden'));
        return this.el.find(".capa_inputtype").each(function(index, inputtype) {
          var classes, cls, display, hideMethod, _i, _len, _results;
          display = _this.inputtypeDisplays[$(inputtype).attr('id')];
          classes = $(inputtype).attr('class').split(' ');
          _results = [];
          for (_i = 0, _len = classes.length; _i < _len; _i++) {
            cls = classes[_i];
            hideMethod = _this.inputtypeHideAnswerMethods[cls];
            if (hideMethod != null) {
              _results.push(hideMethod(inputtype, display));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        });
      }
    };

    Problem.prototype.gentle_alert = function(msg) {
      var alert_elem;
      if (this.el.find('.capa_alert').length) {
        this.el.find('.capa_alert').remove();
      }
      alert_elem = "<div class='capa_alert'>" + msg + "</div>";
      this.el.find('.action').after(alert_elem);
      this.el.find('.capa_alert').css({
        opacity: 0
      }).animate({
        opacity: 1
      }, 700);
      return window.SR.readElts(this.el.find('.capa_alert'));
    };

    Problem.prototype.save = function() {
      if (!this.check_save_waitfor(this.save_internal)) {
        return this.disableAllButtonsWhileRunning(this.save_internal, false);
      }
    };

    Problem.prototype.save_internal = function() {
      var _this = this;
      Logger.log('problem_save', this.answers);
      return $.postWithPrefix("" + this.url + "/problem_save", this.answers, function(response) {
        var saveMessage;
        saveMessage = response.msg;
        _this.gentle_alert(saveMessage);
        return _this.updateProgress(response);
      });
    };

    Problem.prototype.refreshMath = function(event, element) {
      var elid, eqn, jax, mathjax_preprocessor, preprocessor_tag, target;
      if (!element) {
        element = event.target;
      }
      elid = element.id.replace(/^input_/, '');
      target = "display_" + elid;
      preprocessor_tag = "inputtype_" + elid;
      mathjax_preprocessor = this.inputtypeDisplays[preprocessor_tag];
      if ((typeof MathJax !== "undefined" && MathJax !== null) && (jax = MathJax.Hub.getAllJax(target)[0])) {
        eqn = $(element).val();
        if (mathjax_preprocessor) {
          eqn = mathjax_preprocessor(eqn);
        }
        MathJax.Hub.Queue(['Text', jax, eqn], [this.updateMathML, jax, element]);
      }
    };

    Problem.prototype.updateMathML = function(jax, element) {
      try {
        return $("#" + element.id + "_dynamath").val(jax.root.toMathML(''));
      } catch (exception) {
        if (!exception.restart) {
          throw exception;
        }
        if (typeof MathJax !== "undefined" && MathJax !== null) {
          return MathJax.Callback.After([this.refreshMath, jax], exception.restart);
        }
      }
    };

    Problem.prototype.refreshAnswers = function() {
      this.$('input.schematic').each(function(index, element) {
        return element.schematic.update_value();
      });
      this.$(".CodeMirror").each(function(index, element) {
        if (element.CodeMirror.save) {
          return element.CodeMirror.save();
        }
      });
      return this.answers = this.inputs.serialize();
    };

    Problem.prototype.bindResetCorrectness = function() {
      var $inputtypes,
        _this = this;
      $inputtypes = this.el.find(".capa_inputtype").add(this.el.find(".inputtype"));
      return $inputtypes.each(function(index, inputtype) {
        var bindMethod, classes, cls, _i, _len, _results;
        classes = $(inputtype).attr('class').split(' ');
        _results = [];
        for (_i = 0, _len = classes.length; _i < _len; _i++) {
          cls = classes[_i];
          bindMethod = _this.bindResetCorrectnessByInputtype[cls];
          if (bindMethod != null) {
            _results.push(bindMethod(inputtype));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    };

    Problem.prototype.bindResetCorrectnessByInputtype = {
      formulaequationinput: function(element) {
        return $(element).find('input').on('input', function() {
          var $p;
          $p = $(element).find('span.status');
          // Translators: the word unanswered here is about answering a problem the student must solve.;
          return $p.parent().removeClass().addClass("unsubmitted");
        });
      },
      choicegroup: function(element) {
        var $element, id;
        $element = $(element);
        id = ($element.attr('id').match(/^inputtype_(.*)$/))[1];
        return $element.find('input').on('change', function() {
          var $status;
          $status = $("#status_" + id);
          if ($status[0]) {
            $status.removeClass().addClass("unanswered");
            $status.empty().css('display', 'inline-block');
          } else {
            $("<span>", {
              "class": "unanswered",
              "style": "display: inline-block;",
              "id": "status_" + id
            });
          }
          return $element.find("label").removeClass();
        });
      },
      'option-input': function(element) {
        var $select, id;
        $select = $(element).find('select');
        id = ($select.attr('id').match(/^input_(.*)$/))[1];
        return $select.on('change', function() {
          var $status;
          return $status = $("#status_" + id).removeClass().addClass("unanswered").find('span').text(gettext('Status: unsubmitted'));
        });
      },
      textline: function(element) {
        return $(element).find('input').on('input', function() {
          var $p;
          $p = $(element).find('span.status');
          // Translators: the word unanswered here is about answering a problem the student must solve.;
          return $p.parent().removeClass("correct incorrect").addClass("unsubmitted");
        });
      }
    };

    Problem.prototype.inputtypeSetupMethods = {
      'text-input-dynamath': function(element) {
        /*
        Return: function (eqn) -> eqn that preprocesses the user formula input before
                  it is fed into MathJax. Return 'false' if no preprocessor specified
        */

        var data, preprocessor, preprocessorClass, preprocessorClassName;
        data = $(element).find('.text-input-dynamath_data');
        preprocessorClassName = data.data('preprocessor');
        preprocessorClass = window[preprocessorClassName];
        if (preprocessorClass == null) {
          return false;
        } else {
          preprocessor = new preprocessorClass();
          return preprocessor.fn;
        }
      },
      javascriptinput: function(element) {
        var container, data, display, displayClass, evaluation, params, problemState, submission, submissionField;
        data = $(element).find(".javascriptinput_data");
        params = data.data("params");
        submission = data.data("submission");
        evaluation = data.data("evaluation");
        problemState = data.data("problem_state");
        displayClass = window[data.data('display_class')];
        if (evaluation === '') {
          evaluation = null;
        }
        container = $(element).find(".javascriptinput_container");
        submissionField = $(element).find(".javascriptinput_input");
        display = new displayClass(problemState, submission, evaluation, container, submissionField, params);
        display.render();
        return display;
      },
      cminput: function(container) {
        var element, linenumbers, mode, spaces, tabsize;
        element = $(container).find("textarea");
        tabsize = element.data("tabsize");
        mode = element.data("mode");
        linenumbers = element.data("linenums");
        spaces = Array(parseInt(tabsize) + 1).join(" ");
        return CodeMirror.fromTextArea(element[0], {
          lineNumbers: linenumbers,
          indentUnit: tabsize,
          tabSize: tabsize,
          mode: mode,
          matchBrackets: true,
          lineWrapping: true,
          indentWithTabs: false,
          smartIndent: false,
          extraKeys: {
            "Esc": function(cm) {
              $(".grader-status").focus();
              return false;
            },
            "Tab": function(cm) {
              cm.replaceSelection(spaces, "end");
              return false;
            }
          }
        });
      }
    };

    Problem.prototype.inputtypeShowAnswerMethods = {
      choicegroup: function(element, display, answers) {
        var answer, choice, input_id, _i, _len, _results;
        element = $(element);
        input_id = element.attr('id').replace(/inputtype_/, '');
        answer = answers[input_id];
        _results = [];
        for (_i = 0, _len = answer.length; _i < _len; _i++) {
          choice = answer[_i];
          _results.push(element.find("label[for='input_" + input_id + "_" + choice + "']").addClass('choicegroup_correct'));
        }
        return _results;
      },
      javascriptinput: function(element, display, answers) {
        var answer, answer_id;
        answer_id = $(element).attr('id').split("_").slice(1).join("_");
        answer = JSON.parse(answers[answer_id]);
        return display.showAnswer(answer);
      },
      choicetextgroup: function(element, display, answers) {
        var answer, choice, input_id, _i, _len, _results;
        element = $(element);
        input_id = element.attr('id').replace(/inputtype_/, '');
        answer = answers[input_id];
        _results = [];
        for (_i = 0, _len = answer.length; _i < _len; _i++) {
          choice = answer[_i];
          _results.push(element.find("section#forinput" + choice).addClass('choicetextgroup_show_correct'));
        }
        return _results;
      },
      imageinput: function(element, display, answers) {
        var canvas, container, ctx, id, types;
        types = {
          rectangle: function(ctx, coords) {
            var rects, reg;
            reg = /^\(([0-9]+),([0-9]+)\)-\(([0-9]+),([0-9]+)\)$/;
            rects = coords.replace(/\s*/g, '').split(/;/);
            $.each(rects, function(index, rect) {
              var abs, height, points, width;
              abs = Math.abs;
              points = reg.exec(rect);
              if (points) {
                width = abs(points[3] - points[1]);
                height = abs(points[4] - points[2]);
                return ctx.rect(points[1], points[2], width, height);
              }
            });
            ctx.stroke();
            return ctx.fill();
          },
          regions: function(ctx, coords) {
            var parseCoords;
            parseCoords = function(coords) {
              var reg;
              reg = JSON.parse(coords);
              if (typeof reg[0][0][0] === "undefined") {
                reg = [reg];
              }
              return reg;
            };
            return $.each(parseCoords(coords), function(index, region) {
              ctx.beginPath();
              $.each(region, function(index, point) {
                if (index === 0) {
                  return ctx.moveTo(point[0], point[1]);
                } else {
                  return ctx.lineTo(point[0], point[1]);
                }
              });
              ctx.closePath();
              ctx.stroke();
              return ctx.fill();
            });
          }
        };
        element = $(element);
        id = element.attr('id').replace(/inputtype_/, '');
        container = element.find("#answer_" + id);
        canvas = document.createElement('canvas');
        canvas.width = container.data('width');
        canvas.height = container.data('height');
        if (canvas.getContext) {
          ctx = canvas.getContext('2d');
        } else {
          return console.log('Canvas is not supported.');
        }
        ctx.fillStyle = 'rgba(255,255,255,.3)';
        ctx.strokeStyle = "#FF0000";
        ctx.lineWidth = "2";
        if (answers[id]) {
          $.each(answers[id], function(key, value) {
            if ((types[key] != null) && value) {
              return types[key](ctx, value);
            }
          });
          return container.html(canvas);
        } else {
          return console.log("Answer is absent for image input with id=" + id);
        }
      }
    };

    Problem.prototype.inputtypeHideAnswerMethods = {
      choicegroup: function(element, display) {
        element = $(element);
        return element.find('label').removeClass('choicegroup_correct');
      },
      javascriptinput: function(element, display) {
        return display.hideAnswer();
      },
      choicetextgroup: function(element, display) {
        element = $(element);
        return element.find("section[id^='forinput']").removeClass('choicetextgroup_show_correct');
      }
    };

    Problem.prototype.disableAllButtonsWhileRunning = function(operationCallback, isFromCheckOperation) {
      var _this = this;
      this.enableAllButtons(false, isFromCheckOperation);
      return operationCallback().always(function() {
        return _this.enableAllButtons(true, isFromCheckOperation);
      });
    };

    Problem.prototype.enableAllButtons = function(enable, isFromCheckOperation) {
      if (enable) {
        this.resetButton.add(this.saveButton).add(this.hintButton).add(this.showButton).removeClass('is-disabled').attr({
          'aria-disabled': 'false'
        });
      } else {
        this.resetButton.add(this.saveButton).add(this.hintButton).add(this.showButton).addClass('is-disabled').attr({
          'aria-disabled': 'true'
        });
      }
      return this.enableCheckButton(enable, isFromCheckOperation);
    };

    Problem.prototype.enableCheckButton = function(enable, changeText) {
      if (changeText == null) {
        changeText = true;
      }
      if (enable) {
        this.checkButton.removeClass('is-disabled');
        this.checkButton.attr({
          'aria-disabled': 'false'
        });
        if (changeText) {
          return this.checkButtonLabel.text(this.checkButtonCheckText);
        }
      } else {
        this.checkButton.addClass('is-disabled');
        this.checkButton.attr({
          'aria-disabled': 'true'
        });
        if (changeText) {
          return this.checkButtonLabel.text(this.checkButtonCheckingText);
        }
      }
    };

    Problem.prototype.enableCheckButtonAfterResponse = function() {
      this.has_response = true;
      if (!this.has_timed_out) {
        return this.enableCheckButton(false);
      } else {
        return this.enableCheckButton(true);
      }
    };

    Problem.prototype.enableCheckButtonAfterTimeout = function() {
      var enableCheckButton,
        _this = this;
      this.has_timed_out = false;
      this.has_response = false;
      enableCheckButton = function() {
        _this.has_timed_out = true;
        if (_this.has_response) {
          return _this.enableCheckButton(true);
        }
      };
      return window.setTimeout(enableCheckButton, 750);
    };

    Problem.prototype.hint_button = function() {
      var hint_index, next_index,
        _this = this;
      hint_index = this.$('.problem-hint').attr('hint_index');
      if (hint_index === void 0) {
        next_index = 0;
      } else {
        next_index = parseInt(hint_index) + 1;
      }
      return $.postWithPrefix("" + this.url + "/hint_button", {
        hint_index: next_index,
        input_id: this.id
      }, function(response) {
        var hint_container;
        hint_container = _this.$('.problem-hint');
        hint_container.html(response.contents);
        MathJax.Hub.Queue(['Typeset', MathJax.Hub, hint_container[0]]);
        hint_container.attr('hint_index', response.hint_index);
        return _this.$('.hint-button').focus();
      });
    };

    return Problem;

  }).call(this);

}).call(this);
