// Generated by CoffeeScript 1.6.1
(function() {
  var _this = this;

  this.TabsEditingDescriptor = (function() {

    TabsEditingDescriptor.isInactiveClass = "is-inactive";

    function TabsEditingDescriptor(element) {
      var currentTab,
        _this = this;
      this.onSwitchEditor = function(e, firstTime, html_id) {
        return TabsEditingDescriptor.prototype.onSwitchEditor.apply(_this, arguments);
      };
      this.element = element;
      /*
      Not tested on syncing of multiple editors of same type in tabs
      (Like many CodeMirrors).
      */

      this.$tabs = $(".tab", this.element);
      this.$content = $(".component-tab", this.element);
      this.element.find('.editor-tabs .tab').each(function(index, value) {
        return $(value).on('click', _this.onSwitchEditor);
      });
      currentTab = this.$tabs.filter('.current');
      if (currentTab.length !== 1) {
        currentTab = this.$tabs.first();
      }
      this.html_id = this.$tabs.closest('.wrapper-comp-editor').data('html_id');
      currentTab.trigger("click", [true, this.html_id]);
    }

    TabsEditingDescriptor.prototype.onSwitchEditor = function(e, firstTime, html_id) {
      var $currentTarget, content_id, isInactiveClass, onSwitchFunction, previousTab;
      e.preventDefault();
      isInactiveClass = TabsEditingDescriptor.isInactiveClass;
      $currentTarget = $(e.currentTarget);
      if (!$currentTarget.hasClass('current') || firstTime === true) {
        previousTab = null;
        this.$tabs.each(function(index, value) {
          if ($(value).hasClass('current')) {
            return previousTab = $(value).data('tab_name');
          }
        });
        TabsEditingDescriptor.Model.updateValue(this.html_id, previousTab);
        onSwitchFunction = TabsEditingDescriptor.Model.modules[this.html_id].tabSwitch[$currentTarget.data('tab_name')];
        if ($.isFunction(onSwitchFunction)) {
          onSwitchFunction();
        }
        this.$tabs.removeClass('current');
        $currentTarget.addClass('current');
        content_id = $currentTarget.attr('href');
        return this.$content.addClass(isInactiveClass).filter(content_id).removeClass(isInactiveClass);
      }
    };

    TabsEditingDescriptor.prototype.save = function() {
      var current_tab;
      this.element.off('click', '.editor-tabs .tab', this.onSwitchEditor);
      current_tab = this.$tabs.filter('.current').data('tab_name');
      return {
        data: TabsEditingDescriptor.Model.getValue(this.html_id, current_tab)
      };
    };

    TabsEditingDescriptor.prototype.setMetadataEditor = function(metadataEditor) {
      return TabsEditingDescriptor.setMetadataEditor.apply(TabsEditingDescriptor, arguments);
    };

    TabsEditingDescriptor.prototype.getStorage = function() {
      return TabsEditingDescriptor.getStorage();
    };

    TabsEditingDescriptor.prototype.addToStorage = function(id, data) {
      return TabsEditingDescriptor.addToStorage.apply(TabsEditingDescriptor, arguments);
    };

    TabsEditingDescriptor.Model = {
      addModelUpdate: function(id, tabName, modelUpdateFunction) {
        /*
        Function that registers  'modelUpdate' functions of every tab.
        These functions are used to update value, which will be returned
        by calling save on component.
        */
        this.initialize(id);
        return this.modules[id].modelUpdate[tabName] = modelUpdateFunction;
      },
      addOnSwitch: function(id, tabName, onSwitchFunction) {
        /*
        Function that registers functions invoked when switching
        to particular tab.
        */
        this.initialize(id);
        return this.modules[id].tabSwitch[tabName] = onSwitchFunction;
      },
      updateValue: function(id, tabName) {
        /*
        Function that invokes when switching tabs.
        It ensures that data from previous tab is stored.
        If new tab need this data, it should retrieve it from
        stored value.
        */

        var modelUpdateFunction;
        this.initialize(id);
        modelUpdateFunction = this.modules[id]['modelUpdate'][tabName];
        if ($.isFunction(modelUpdateFunction)) {
          return this.modules[id]['value'] = modelUpdateFunction();
        }
      },
      getValue: function(id, tabName) {
        /*
        Retrieves stored data on component save.
        1. When we switching tabs - previous tab data is always saved to @[id].value
        2. If current tab have registered 'modelUpdate' method, it should be invoked 1st.
        (If we have edited in 1st tab, then switched to 2nd, 2nd tab should
        care about getting data from @[id].value in onSwitch.)
        */
        if (!this.modules[id]) {
          return null;
        }
        if ($.isFunction(this.modules[id]['modelUpdate'][tabName])) {
          return this.modules[id]['modelUpdate'][tabName]();
        } else {
          if (typeof this.modules[id]['value'] === 'undefined') {
            return null;
          } else {
            return this.modules[id]['value'];
          }
        }
      },
      modules: {},
      Storage: {},
      initialize: function(id) {
        /*
        Initialize objects per id. Id is html_id of descriptor.
        */
        this.modules[id] = this.modules[id] || {};
        this.modules[id].tabSwitch = this.modules[id]['tabSwitch'] || {};
        return this.modules[id].modelUpdate = this.modules[id]['modelUpdate'] || {};
      }
    };

    TabsEditingDescriptor.setMetadataEditor = function(metadataEditor) {
      return TabsEditingDescriptor.Model.Storage['MetadataEditor'] = metadataEditor;
    };

    TabsEditingDescriptor.addToStorage = function(id, data) {
      return TabsEditingDescriptor.Model.Storage[id] = data;
    };

    TabsEditingDescriptor.getStorage = function() {
      return TabsEditingDescriptor.Model.Storage;
    };

    return TabsEditingDescriptor;

  })();

}).call(this);
