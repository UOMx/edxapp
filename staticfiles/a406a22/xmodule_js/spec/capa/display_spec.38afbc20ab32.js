// Generated by CoffeeScript 1.6.1
(function() {

  describe('Problem', function() {
    var problem_content_default;
    problem_content_default = readFixtures('problem_content.html');
    beforeEach(function() {
      window.MathJax = {
        Hub: jasmine.createSpyObj('MathJax.Hub', ['getAllJax', 'Queue']),
        Callback: jasmine.createSpyObj('MathJax.Callback', ['After'])
      };
      this.stubbedJax = {
        root: jasmine.createSpyObj('jax.root', ['toMathML'])
      };
      MathJax.Hub.getAllJax.andReturn([this.stubbedJax]);
      window.update_schematics = function() {};
      spyOn(SR, 'readElts');
      spyOn(SR, 'readText');
      jasmine.stubRequests();
      loadFixtures('problem.html');
      spyOn(Logger, 'log');
      return spyOn($.fn, 'load').andCallFake(function(url, callback) {
        $(this).html(problem_content_default);
        return callback();
      });
    });
    describe('constructor', function() {
      it('set the element from html', function() {
        this.problem999 = new Problem("        <section class='xblock xblock-student_view xmodule_display xmodule_CapaModule' data-type='Problem'>          <section id='problem_999'                   class='problems-wrapper'                   data-problem-id='i4x://edX/999/problem/Quiz'                   data-url='/problem/quiz/'>          </section>        </section>        ");
        return expect(this.problem999.element_id).toBe('problem_999');
      });
      return it('set the element from loadFixtures', function() {
        this.problem1 = new Problem($('.xblock-student_view'));
        return expect(this.problem1.element_id).toBe('problem_1');
      });
    });
    describe('bind', function() {
      beforeEach(function() {
        spyOn(window, 'update_schematics');
        MathJax.Hub.getAllJax.andReturn([this.stubbedJax]);
        return this.problem = new Problem($('.xblock-student_view'));
      });
      it('set mathjax typeset', function() {
        return expect(MathJax.Hub.Queue).toHaveBeenCalled();
      });
      it('update schematics', function() {
        return expect(window.update_schematics).toHaveBeenCalled();
      });
      it('bind answer refresh on button click', function() {
        return expect($('div.action button')).toHandleWith('click', this.problem.refreshAnswers);
      });
      it('bind the check button', function() {
        return expect($('div.action button.check')).toHandleWith('click', this.problem.check_fd);
      });
      it('bind the reset button', function() {
        return expect($('div.action button.reset')).toHandleWith('click', this.problem.reset);
      });
      it('bind the show button', function() {
        return expect($('div.action button.show')).toHandleWith('click', this.problem.show);
      });
      it('bind the save button', function() {
        return expect($('div.action button.save')).toHandleWith('click', this.problem.save);
      });
      return it('bind the math input', function() {
        return expect($('input.math')).toHandleWith('keyup', this.problem.refreshMath);
      });
    });
    describe('bind_with_custom_input_id', function() {
      beforeEach(function() {
        spyOn(window, 'update_schematics');
        MathJax.Hub.getAllJax.andReturn([this.stubbedJax]);
        this.problem = new Problem($('.xblock-student_view'));
        return $(this).html(readFixtures('problem_content_1240.html'));
      });
      it('bind the check button', function() {
        return expect($('div.action button.check')).toHandleWith('click', this.problem.check_fd);
      });
      return it('bind the show button', function() {
        return expect($('div.action button.show')).toHandleWith('click', this.problem.show);
      });
    });
    describe('renderProgressState', function() {
      beforeEach(function() {
        return this.problem = new Problem($('.xblock-student_view'));
      });
      describe('with a status of "none"', function() {
        it('reports the number of points possible', function() {
          this.problem.el.data('progress_status', 'none');
          this.problem.el.data('progress_detail', '0/1');
          this.problem.renderProgressState();
          return expect(this.problem.$('.problem-progress').html()).toEqual("(1 point possible)");
        });
        return it('displays the number of points possible when rendering happens with the content', function() {
          this.problem.el.data('progress_status', 'none');
          this.problem.el.data('progress_detail', '0/2');
          expect(this.problem.$('.problem-progress').html()).toEqual("");
          this.problem.render(problem_content_default);
          return expect(this.problem.$('.problem-progress').html()).toEqual("(2 points possible)");
        });
      });
      return describe('with any other valid status', function() {
        it('reports the current score', function() {
          this.problem.el.data('progress_status', 'foo');
          this.problem.el.data('progress_detail', '1/1');
          this.problem.renderProgressState();
          return expect(this.problem.$('.problem-progress').html()).toEqual("(1/1 point)");
        });
        return it('shows current score when rendering happens with the content', function() {
          this.problem.el.data('progress_status', 'test status');
          this.problem.el.data('progress_detail', '2/2');
          expect(this.problem.$('.problem-progress').html()).toEqual("");
          this.problem.render(problem_content_default);
          return expect(this.problem.$('.problem-progress').html()).toEqual("(2/2 points)");
        });
      });
    });
    describe('render', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        this.bind = this.problem.bind;
        return spyOn(this.problem, 'bind');
      });
      describe('with content given', function() {
        beforeEach(function() {
          return this.problem.render('Hello World');
        });
        it('render the content', function() {
          return expect(this.problem.el.html()).toEqual('Hello World');
        });
        return it('re-bind the content', function() {
          return expect(this.problem.bind).toHaveBeenCalled();
        });
      });
      return describe('with no content given', function() {
        beforeEach(function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
            return callback({
              html: "Hello World"
            });
          });
          return this.problem.render();
        });
        it('load the content via ajax', function() {
          return expect(this.problem.el.html()).toEqual('Hello World');
        });
        return it('re-bind the content', function() {
          return expect(this.problem.bind).toHaveBeenCalled();
        });
      });
    });
    describe('check_fd', function() {
      beforeEach(function() {
        $('.xblock-student_view').after('<input type="file" />');
        this.problem = new Problem($('.xblock-student_view'));
        return spyOn(this.problem, 'check');
      });
      return it('check method is called if input of type file is not in problem', function() {
        this.problem.check_fd();
        return expect(this.problem.check).toHaveBeenCalled();
      });
    });
    describe('check', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        return this.problem.answers = 'foo=1&bar=2';
      });
      it('log the problem_check event', function() {
        spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
          var promise;
          return promise = {
            always: function(callable) {
              return callable();
            },
            done: function(callable) {
              return callable();
            }
          };
        });
        this.problem.check();
        return expect(Logger.log).toHaveBeenCalledWith('problem_check', 'foo=1&bar=2');
      });
      it('log the problem_graded event, after the problem is done grading.', function() {
        spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
          var promise, response;
          response = {
            success: 'correct',
            contents: 'mock grader response'
          };
          callback(response);
          return promise = {
            always: function(callable) {
              return callable();
            },
            done: function(callable) {
              return callable();
            }
          };
        });
        this.problem.check();
        return expect(Logger.log).toHaveBeenCalledWith('problem_graded', ['foo=1&bar=2', 'mock grader response'], this.problem.id);
      });
      it('submit the answer for check', function() {
        spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
          var promise;
          return promise = {
            always: function(callable) {
              return callable();
            },
            done: function(callable) {
              return callable();
            }
          };
        });
        this.problem.check();
        return expect($.postWithPrefix).toHaveBeenCalledWith('/problem/Problem1/problem_check', 'foo=1&bar=2', jasmine.any(Function));
      });
      describe('when the response is correct', function() {
        return it('call render with returned content', function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
            var promise;
            callback({
              success: 'correct',
              contents: 'Correct!'
            });
            return promise = {
              always: function(callable) {
                return callable();
              },
              done: function(callable) {
                return callable();
              }
            };
          });
          this.problem.check();
          expect(this.problem.el.html()).toEqual('Correct!');
          return expect(window.SR.readElts).toHaveBeenCalled();
        });
      });
      describe('when the response is incorrect', function() {
        return it('call render with returned content', function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
            var promise;
            callback({
              success: 'incorrect',
              contents: 'Incorrect!'
            });
            return promise = {
              always: function(callable) {
                return callable();
              },
              done: function(callable) {
                return callable();
              }
            };
          });
          this.problem.check();
          expect(this.problem.el.html()).toEqual('Incorrect!');
          return expect(window.SR.readElts).toHaveBeenCalled();
        });
      });
      it('tests if all the capa buttons are disabled while checking', function() {
        runs(function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
            var promise;
            callback({
              success: 'incorrect',
              contents: 'Incorrect!'
            });
            return promise = {
              always: function(callable) {
                return callable();
              },
              done: function(callable) {
                return callable();
              }
            };
          });
          spyOn(this.problem, 'enableAllButtons');
          this.problem.check();
          return expect(this.problem.enableAllButtons).toHaveBeenCalledWith(false, true);
        });
        waitsFor((function() {
          return jQuery.active === 0;
        }), "jQuery requests finished", 1000);
        return runs(function() {
          return expect(this.problem.enableAllButtons).toHaveBeenCalledWith(true, true);
        });
      });
      return it('tests the expected change in text of check button', function() {
        runs(function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
            var promise;
            return promise = {
              always: function(callable) {
                return callable();
              },
              done: function(callable) {
                return callable();
              }
            };
          });
          spyOn(this.problem.checkButtonLabel, 'text');
          this.problem.check();
          return expect(this.problem.checkButtonLabel.text).toHaveBeenCalledWith('Checking...');
        });
        waitsFor((function() {
          return jQuery.active === 0;
        }), "jQuery requests finished", 1000);
        return runs(function() {
          return expect(this.problem.checkButtonLabel.text).toHaveBeenCalledWith('Check');
        });
      });
    });
    describe('reset', function() {
      beforeEach(function() {
        return this.problem = new Problem($('.xblock-student_view'));
      });
      it('log the problem_reset event', function() {
        spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
          var promise;
          return promise = {
            always: function(callable) {
              return callable();
            }
          };
        });
        this.problem.answers = 'foo=1&bar=2';
        this.problem.reset();
        return expect(Logger.log).toHaveBeenCalledWith('problem_reset', 'foo=1&bar=2');
      });
      it('POST to the problem reset page', function() {
        spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
          var promise;
          return promise = {
            always: function(callable) {
              return callable();
            }
          };
        });
        this.problem.reset();
        return expect($.postWithPrefix).toHaveBeenCalledWith('/problem/Problem1/problem_reset', {
          id: 'i4x://edX/101/problem/Problem1'
        }, jasmine.any(Function));
      });
      it('render the returned content', function() {
        spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
          var promise;
          callback({
            html: "Reset!"
          });
          return promise = {
            always: function(callable) {
              return callable();
            }
          };
        });
        this.problem.reset();
        return expect(this.problem.el.html()).toEqual('Reset!');
      });
      return it('tests if all the buttons are disabled and the text of check button remains same while resetting', function() {
        runs(function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
            var promise;
            return promise = {
              always: function(callable) {
                return callable();
              }
            };
          });
          spyOn(this.problem, 'enableAllButtons');
          this.problem.reset();
          expect(this.problem.enableAllButtons).toHaveBeenCalledWith(false, false);
          return expect(this.problem.checkButtonLabel).toHaveText('Check');
        });
        waitsFor((function() {
          return jQuery.active === 0;
        }), "jQuery requests finished", 1000);
        return runs(function() {
          expect(this.problem.enableAllButtons).toHaveBeenCalledWith(true, false);
          return expect(this.problem.checkButtonLabel).toHaveText('Check');
        });
      });
    });
    describe('show', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        return this.problem.el.prepend('<div id="answer_1_1" /><div id="answer_1_2" />');
      });
      describe('when the answer has not yet shown', function() {
        beforeEach(function() {
          return this.problem.el.removeClass('showed');
        });
        it('log the problem_show event', function() {
          this.problem.show();
          return expect(Logger.log).toHaveBeenCalledWith('problem_show', {
            problem: 'i4x://edX/101/problem/Problem1'
          });
        });
        it('fetch the answers', function() {
          spyOn($, 'postWithPrefix');
          this.problem.show();
          return expect($.postWithPrefix).toHaveBeenCalledWith('/problem/Problem1/problem_show', jasmine.any(Function));
        });
        it('show the answers', function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
            return callback({
              answers: {
                '1_1': 'One',
                '1_2': 'Two'
              }
            });
          });
          this.problem.show();
          expect($('#answer_1_1')).toHaveHtml('One');
          return expect($('#answer_1_2')).toHaveHtml('Two');
        });
        it('toggle the show answer button', function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
            return callback({
              answers: {}
            });
          });
          this.problem.show();
          expect($('.show .show-label')).toHaveText('Hide Answer');
          return expect(window.SR.readElts).toHaveBeenCalled();
        });
        it('toggle the show answer button, answers are strings', function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
            return callback({
              answers: {
                '1_1': 'One',
                '1_2': 'Two'
              }
            });
          });
          this.problem.show();
          expect($('.show .show-label')).toHaveText('Hide Answer');
          return expect(window.SR.readElts).toHaveBeenCalledWith(['<p>Answer: One</p>', '<p>Answer: Two</p>']);
        });
        it('toggle the show answer button, answers are elements', function() {
          var answer1, answer2;
          answer1 = '<div><span class="detailed-solution">one</span></div>';
          answer2 = '<div><span class="detailed-solution">two</span></div>';
          spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
            return callback({
              answers: {
                '1_1': answer1,
                '1_2': answer2
              }
            });
          });
          this.problem.show();
          expect($('.show .show-label')).toHaveText('Hide Answer');
          return expect(window.SR.readElts).toHaveBeenCalledWith([jasmine.any(jQuery), jasmine.any(jQuery)]);
        });
        it('add the showed class to element', function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
            return callback({
              answers: {}
            });
          });
          this.problem.show();
          return expect(this.problem.el).toHaveClass('showed');
        });
        it('reads the answers', function() {
          runs(function() {
            spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
              return callback({
                answers: 'answers'
              });
            });
            return this.problem.show();
          });
          waitsFor((function() {
            return jQuery.active === 0;
          }), "jQuery requests finished", 1000);
          return runs(function() {
            return expect(window.SR.readElts).toHaveBeenCalled();
          });
        });
        describe('multiple choice question', function() {
          beforeEach(function() {
            return this.problem.el.prepend('<label for="input_1_1_1"><input type="checkbox" name="input_1_1" id="input_1_1_1" value="1"> One</label>\n<label for="input_1_1_2"><input type="checkbox" name="input_1_1" id="input_1_1_2" value="2"> Two</label>\n<label for="input_1_1_3"><input type="checkbox" name="input_1_1" id="input_1_1_3" value="3"> Three</label>\n<label for="input_1_2_1"><input type="radio" name="input_1_2" id="input_1_2_1" value="1"> Other</label>');
          });
          return it('set the correct_answer attribute on the choice', function() {
            spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
              return callback({
                answers: {
                  '1_1': [2, 3]
                }
              });
            });
            this.problem.show();
            expect($('label[for="input_1_1_1"]')).not.toHaveAttr('correct_answer', 'true');
            expect($('label[for="input_1_1_2"]')).toHaveAttr('correct_answer', 'true');
            expect($('label[for="input_1_1_3"]')).toHaveAttr('correct_answer', 'true');
            return expect($('label[for="input_1_2_1"]')).not.toHaveAttr('correct_answer', 'true');
          });
        });
        describe('radio text question', function() {
          var radio_text_xml;
          radio_text_xml = '<section class="problem">\n  <div><p></p><span><section id="choicetextinput_1_2_1" class="choicetextinput">\n\n<form class="choicetextgroup capa_inputtype" id="inputtype_1_2_1">\n  <div class="indicator-container">\n    <span class="unanswered" style="display:inline-block;" id="status_1_2_1"></span>\n  </div>\n  <fieldset>\n    <section id="forinput1_2_1_choiceinput_0bc">\n      <input class="ctinput" type="radio" name="choiceinput_1_2_1" id="1_2_1_choiceinput_0bc" value="choiceinput_0"">\n      <input class="ctinput" type="text" name="choiceinput_0_textinput_0" id="1_2_1_choiceinput_0_textinput_0" value=" ">\n      <p id="answer_1_2_1_choiceinput_0bc" class="answer"></p>\n    </>\n    <section id="forinput1_2_1_choiceinput_1bc">\n      <input class="ctinput" type="radio" name="choiceinput_1_2_1" id="1_2_1_choiceinput_1bc" value="choiceinput_1" >\n      <input class="ctinput" type="text" name="choiceinput_1_textinput_0" id="1_2_1_choiceinput_1_textinput_0" value=" " >\n      <p id="answer_1_2_1_choiceinput_1bc" class="answer"></p>\n    </section>\n    <section id="forinput1_2_1_choiceinput_2bc">\n      <input class="ctinput" type="radio" name="choiceinput_1_2_1" id="1_2_1_choiceinput_2bc" value="choiceinput_2" >\n      <input class="ctinput" type="text" name="choiceinput_2_textinput_0" id="1_2_1_choiceinput_2_textinput_0" value=" " >\n      <p id="answer_1_2_1_choiceinput_2bc" class="answer"></p>\n    </section></fieldset><input class="choicetextvalue" type="hidden" name="input_1_2_1" id="input_1_2_1"></form>\n</section></span></div>\n</section>';
          beforeEach(function() {
            return this.problem.el.prepend(radio_text_xml);
          });
          it('sets the correct class on the section for the correct choice', function() {
            spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
              return callback({
                answers: {
                  "1_2_1": ["1_2_1_choiceinput_0bc"],
                  "1_2_1_choiceinput_0bc": "3"
                }
              });
            });
            this.problem.show();
            expect($('#forinput1_2_1_choiceinput_0bc').attr('class')).toEqual('choicetextgroup_show_correct');
            expect($('#answer_1_2_1_choiceinput_0bc').text()).toEqual('3');
            expect($('#answer_1_2_1_choiceinput_1bc').text()).toEqual('');
            return expect($('#answer_1_2_1_choiceinput_2bc').text()).toEqual('');
          });
          return it('Should not disable input fields', function() {
            spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
              return callback({
                answers: {
                  "1_2_1": ["1_2_1_choiceinput_0bc"],
                  "1_2_1_choiceinput_0bc": "3"
                }
              });
            });
            this.problem.show();
            expect($('input#1_2_1_choiceinput_0bc').attr('disabled')).not.toEqual('disabled');
            expect($('input#1_2_1_choiceinput_1bc').attr('disabled')).not.toEqual('disabled');
            expect($('input#1_2_1_choiceinput_2bc').attr('disabled')).not.toEqual('disabled');
            return expect($('input#1_2_1').attr('disabled')).not.toEqual('disabled');
          });
        });
        return describe('imageinput', function() {
          var DEFAULTS, assertAnswer, getImage, imageinput_html, stubRequest,
            _this = this;
          imageinput_html = readFixtures('imageinput.underscore');
          DEFAULTS = {
            id: '12345',
            width: '300',
            height: '400'
          };
          beforeEach(function() {
            this.problem = new Problem($('.xblock-student_view'));
            return this.problem.el.prepend(_.template(imageinput_html)(DEFAULTS));
          });
          assertAnswer = function(problem, data) {
            stubRequest(data);
            problem.show();
            return $.each(data['answers'], function(id, answer) {
              var el, img;
              img = getImage(answer);
              el = $('#inputtype_' + id);
              return expect(img).toImageDiffEqual(el.find('canvas')[0]);
            });
          };
          stubRequest = function(data) {
            return spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
              return callback(data);
            });
          };
          getImage = function(coords, c_width, c_height) {
            var canvas, ctx, types;
            types = {
              rectangle: function(coords) {
                var rects, reg;
                reg = /^\(([0-9]+),([0-9]+)\)-\(([0-9]+),([0-9]+)\)$/;
                rects = coords.replace(/\s*/g, '').split(/;/);
                $.each(rects, function(index, rect) {
                  var abs, height, points, width;
                  abs = Math.abs;
                  points = reg.exec(rect);
                  if (points) {
                    width = abs(points[3] - points[1]);
                    height = abs(points[4] - points[2]);
                    return ctx.rect(points[1], points[2], width, height);
                  }
                });
                ctx.stroke();
                return ctx.fill();
              },
              regions: function(coords) {
                var parseCoords;
                parseCoords = function(coords) {
                  var reg;
                  reg = JSON.parse(coords);
                  if (typeof reg[0][0][0] === "undefined") {
                    reg = [reg];
                  }
                  return reg;
                };
                return $.each(parseCoords(coords), function(index, region) {
                  ctx.beginPath();
                  $.each(region, function(index, point) {
                    if (index === 0) {
                      return ctx.moveTo(point[0], point[1]);
                    } else {
                      return ctx.lineTo(point[0], point[1]);
                    }
                  });
                  ctx.closePath();
                  ctx.stroke();
                  return ctx.fill();
                });
              }
            };
            canvas = document.createElement('canvas');
            canvas.width = c_width || 100;
            canvas.height = c_height || 100;
            if (canvas.getContext) {
              ctx = canvas.getContext('2d');
            } else {
              return console.log('Canvas is not supported.');
            }
            ctx.fillStyle = 'rgba(255,255,255,.3)';
            ctx.strokeStyle = "#FF0000";
            ctx.lineWidth = "2";
            $.each(coords, function(key, value) {
              if ((types[key] != null) && value) {
                return types[key](value);
              }
            });
            return canvas;
          };
          it('rectangle is drawn correctly', function() {
            return assertAnswer(this.problem, {
              'answers': {
                '12345': {
                  'rectangle': '(10,10)-(30,30)',
                  'regions': null
                }
              }
            });
          });
          it('region is drawn correctly', function() {
            return assertAnswer(this.problem, {
              'answers': {
                '12345': {
                  'rectangle': null,
                  'regions': '[[10,10],[30,30],[70,30],[20,30]]'
                }
              }
            });
          });
          it('mixed shapes are drawn correctly', function() {
            return assertAnswer(this.problem, {
              'answers': {
                '12345': {
                  'rectangle': '(10,10)-(30,30);(5,5)-(20,20)',
                  'regions': '[\n  [[50,50],[40,40],[70,30],[50,70]],\n  [[90,95],[95,95],[90,70],[70,70]]\n]'
                }
              }
            });
          });
          it('multiple image inputs draw answers on separate canvases', function() {
            var data;
            data = {
              id: '67890',
              width: '400',
              height: '300'
            };
            this.problem.el.prepend(_.template(imageinput_html)(data));
            return assertAnswer(this.problem, {
              'answers': {
                '12345': {
                  'rectangle': null,
                  'regions': '[[10,10],[30,30],[70,30],[20,30]]'
                },
                '67890': {
                  'rectangle': '(10,10)-(30,30)',
                  'regions': null
                }
              }
            });
          });
          return it('dictionary with answers doesn\'t contain answer for current id', function() {
            var el;
            spyOn(console, 'log');
            stubRequest({
              'answers': {}
            });
            this.problem.show();
            el = $('#inputtype_12345');
            expect(el.find('canvas')).not.toExist();
            return expect(console.log).toHaveBeenCalledWith('Answer is absent for image input with id=12345');
          });
        });
      });
      return describe('when the answers are already shown', function() {
        beforeEach(function() {
          this.problem.el.addClass('showed');
          this.problem.el.prepend('<label for="input_1_1_1" correct_answer="true">\n  <input type="checkbox" name="input_1_1" id="input_1_1_1" value="1" />\n  One\n</label>');
          $('#answer_1_1').html('One');
          return $('#answer_1_2').html('Two');
        });
        it('hide the answers', function() {
          this.problem.show();
          expect($('#answer_1_1')).toHaveHtml('');
          expect($('#answer_1_2')).toHaveHtml('');
          return expect($('label[for="input_1_1_1"]')).not.toHaveAttr('correct_answer');
        });
        it('toggle the show answer button', function() {
          this.problem.show();
          return expect($('.show .show-label')).toHaveText('Show Answer');
        });
        return it('remove the showed class from element', function() {
          this.problem.show();
          return expect(this.problem.el).not.toHaveClass('showed');
        });
      });
    });
    describe('save', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        return this.problem.answers = 'foo=1&bar=2';
      });
      it('log the problem_save event', function() {
        spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
          var promise;
          return promise = {
            always: function(callable) {
              return callable();
            }
          };
        });
        this.problem.save();
        return expect(Logger.log).toHaveBeenCalledWith('problem_save', 'foo=1&bar=2');
      });
      it('POST to save problem', function() {
        spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
          var promise;
          return promise = {
            always: function(callable) {
              return callable();
            }
          };
        });
        this.problem.save();
        return expect($.postWithPrefix).toHaveBeenCalledWith('/problem/Problem1/problem_save', 'foo=1&bar=2', jasmine.any(Function));
      });
      it('reads the save message', function() {
        runs(function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
            var promise;
            callback({
              success: 'OK'
            });
            return promise = {
              always: function(callable) {
                return callable();
              }
            };
          });
          return this.problem.save();
        });
        waitsFor((function() {
          return jQuery.active === 0;
        }), "jQuery requests finished", 1000);
        return runs(function() {
          return expect(window.SR.readElts).toHaveBeenCalled();
        });
      });
      return it('tests if all the buttons are disabled and the text of check button does not change while saving.', function() {
        runs(function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
            var promise;
            callback({
              success: 'OK'
            });
            return promise = {
              always: function(callable) {
                return callable();
              }
            };
          });
          spyOn(this.problem, 'enableAllButtons');
          this.problem.save();
          expect(this.problem.enableAllButtons).toHaveBeenCalledWith(false, false);
          return expect(this.problem.checkButtonLabel).toHaveText('Check');
        });
        waitsFor((function() {
          return jQuery.active === 0;
        }), "jQuery requests finished", 1000);
        return runs(function() {
          expect(this.problem.enableAllButtons).toHaveBeenCalledWith(true, false);
          return expect(this.problem.checkButtonLabel).toHaveText('Check');
        });
      });
    });
    describe('refreshMath', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        $('#input_example_1').val('E=mc^2');
        return this.problem.refreshMath({
          target: $('#input_example_1').get(0)
        });
      });
      return it('should queue the conversion and MathML element update', function() {
        return expect(MathJax.Hub.Queue).toHaveBeenCalledWith(['Text', this.stubbedJax, 'E=mc^2'], [this.problem.updateMathML, this.stubbedJax, $('#input_example_1').get(0)]);
      });
    });
    describe('updateMathML', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        return this.stubbedJax.root.toMathML.andReturn('<MathML>');
      });
      describe('when there is no exception', function() {
        beforeEach(function() {
          return this.problem.updateMathML(this.stubbedJax, $('#input_example_1').get(0));
        });
        return it('convert jax to MathML', function() {
          return expect($('#input_example_1_dynamath')).toHaveValue('<MathML>');
        });
      });
      return describe('when there is an exception', function() {
        beforeEach(function() {
          this.stubbedJax.root.toMathML.andThrow({
            restart: true
          });
          return this.problem.updateMathML(this.stubbedJax, $('#input_example_1').get(0));
        });
        return it('should queue up the exception', function() {
          return expect(MathJax.Callback.After).toHaveBeenCalledWith([this.problem.refreshMath, this.stubbedJax], true);
        });
      });
    });
    describe('refreshAnswers', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        this.problem.el.html('<textarea class="CodeMirror" />\n<input id="input_1_1" name="input_1_1" class="schematic" value="one" />\n<input id="input_1_2" name="input_1_2" value="two" />\n<input id="input_bogus_3" name="input_bogus_3" value="three" />');
        this.stubSchematic = {
          update_value: jasmine.createSpy('schematic')
        };
        this.stubCodeMirror = {
          save: jasmine.createSpy('CodeMirror')
        };
        $('input.schematic').get(0).schematic = this.stubSchematic;
        return $('textarea.CodeMirror').get(0).CodeMirror = this.stubCodeMirror;
      });
      it('update each schematic', function() {
        this.problem.refreshAnswers();
        return expect(this.stubSchematic.update_value).toHaveBeenCalled();
      });
      return it('update each code block', function() {
        this.problem.refreshAnswers();
        return expect(this.stubCodeMirror.save).toHaveBeenCalled();
      });
    });
    describe('multiple JsInput in single problem', function() {
      var jsinput_html;
      jsinput_html = readFixtures('jsinput_problem.html');
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        return this.problem.render(jsinput_html);
      });
      return it('check_save_waitfor should return false', function() {
        $(this.problem.inputs[0]).data('waitfor', function() {});
        return expect(this.problem.check_save_waitfor()).toEqual(false);
      });
    });
    return describe('Submitting an xqueue-graded problem', function() {
      var matlabinput_html;
      matlabinput_html = readFixtures('matlabinput_problem.html');
      beforeEach(function() {
        spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
          return callback({
            html: matlabinput_html
          });
        });
        jasmine.Clock.useMock();
        this.problem = new Problem($('.xblock-student_view'));
        spyOn(this.problem, 'poll').andCallThrough();
        return this.problem.render(matlabinput_html);
      });
      return it('check that we stop polling after a fixed amount of time', function() {
        var num_calls, time_step, time_steps, _fn, _i, _len,
          _this = this;
        expect(this.problem.poll).not.toHaveBeenCalled();
        jasmine.Clock.tick(1);
        time_steps = [1000, 2000, 4000, 8000, 16000, 32000];
        num_calls = 1;
        _fn = function(time_step) {
          jasmine.Clock.tick(time_step);
          expect(_this.problem.poll.callCount).toEqual(num_calls);
          return num_calls += 1;
        };
        for (_i = 0, _len = time_steps.length; _i < _len; _i++) {
          time_step = time_steps[_i];
          _fn(time_step);
        }
        jasmine.Clock.tick(64000);
        expect(this.problem.poll.callCount).toEqual(6);
        return expect($('.capa_alert').text()).toEqual("The grading process is still running. Refresh the page to see updates.");
      });
    });
  });

}).call(this);
